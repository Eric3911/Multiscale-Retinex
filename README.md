# Multiscale-Retinex
  多层视网膜去云雾识别
  
  MSR, MSRCR, MSRCP, autoMSRCR


关于Rentinex,在共享两篇比较经典的英文论文：

    Multi-Scale Retinex for Color Image Enhancement
    A Multiscale Retinex for Bridging the Gap Between Color Images and the Human Observation of Scenes
    
Retinex这个词是由视网膜(Retina)和大脑皮层(Cortex) 两个词组合构成的。Retinex理论主要包含了两个方面的内容：物体的颜色是由物体对长波、 中波和短波光线的反射能力决定的，而不是由反射光强度的绝对值决定的；物体的色彩不受光照 非均匀性的影响,具有一致性 。 

    根据Retinex理论，人眼感知物体的亮度取决于环境的照明和物体表面对照射光的反射，其数学表达式为：

            I(x,y)=L(x,y)*R(x,y)　　　　　　　　　　　　　　　　　　　　　　　　　　　　(2-1)

　　式中： I(x,y)代表被观察或照相机接收到的图像信号；L(x,y)代表环境光的照射分量 ；R(x,y)表示携带图像细节信息的目标物体的反射分量 。

    将(2-1)式两边取对数，则可抛开入射光的性质得到物体的本来面貌，即有关系式 ：

       Log[R(x,y)] = Log[I(x,y)]-Log[L(x,y)];　　　　　　　　　　　　　　　　  　　　　(2-2)

    对上面的理论的进行一个简单的注释吧。把这个技术运用到图像处理上，就是针对我们现在已经获得的一副图像数据I(x,y），计算出对应的R(x,y)，则R(x,y)认为是增强后的图像，现在的关键是如何得到L(X,Y)。Retinex理论的提出者指出这个L(x,y）可以通过对图像数据I(x,y）进行高斯模糊而得到，很多论文中都列出了那个中心/围绕函数以及需要归一化的K值，搞的很多新手都不明白是什么了，其实就是一个模糊而已。从实际运用的角度来说，也可以用均值模糊来代替高斯模糊。

     因此这个算法的细路就很简单了，具体步骤如下：

     1、输入: 原始图像数据I(x,y),尺度（也就是所谓的模糊的半径）

     2、处理：(1) 计算原始图像按指定尺度进行模糊后的图像 L(x,y);

              (2) 按照2-2式的计算方法计算出 Log[R(x,y)]的值。

              (3) 将 Log[R(x,y)]量化为0到255范围的像素值，作为最终的输出。

    可以看得出，算法很简单，其核心的东西还是在于高斯模糊的实现。关于高斯模糊，网上有很多快速优化的文章参考，具体的参考代码可能很少有好人提供的。

    注意到一点，似乎在量化的时候没有谁会将 Log[R(x,y)]进行Exp函数的运算而直接得到R(x,y)，至于为什么，我无法给出明确的答案。

    量化的方式其实有很多种，而这个方法在很大的程度上对处理的效果有着决定性的影响。至今我没看到有哪一篇论文对这一块讲的很清楚，也不知道他们的那些结果是如何取得的，一种最简单的方式就是计算出Log[R(x,y)]的最大值Max和最小值Min,然后对每一个值Value，进行线性量化，公式为：

            R(x,y) = ( Value - Min ) / (Max - Min) * (255-0)                           (2-3)
  （1）MSRCR效果要比MSR好很多，基本消除了色偏。

        （2）对于MSRCR，尺度数对结果的影像不是特别大，但是随着尺度数的增加，算法耗时会线性增加，因此，一般尺度数取3就较为合适了。
